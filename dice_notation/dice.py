# -*- coding: utf-8 -*-

from abc import ABCMeta, abstractmethod
from random import randint

"""
Dice classes.

These are just plain dice, not dice notation, even thought they may be used
for handling that too.

The classes in this file will allow creating and using dice and rollable
entities, which are able to generate a random value.

There are two dice classes, the Dice is just the bare dice, while the
RollableDice is an extension, which allows rolling the dice.
"""

__author__ = 'Benardo Mart√≠nez Garrido'
__license__ = 'MIT'


class Rollable(object, metaclass=ABCMeta):
    """
    Interface for rollable classes.

    While rolling implies using dice to generate a random value, this interface
    just takes care of generating a random value.

    This way it not only can support any kind of dice, but also more complex
    constructions such as dice notation expressions, where calling the roll
    method would execute the full expression.

    As such, the value generated by rolling may be anything.
    """

    def __init__(self):
        pass

    @abstractmethod
    def roll(self):
        """
        Generates a random value.

        This can be anything, the only expectation is that the output
        is randomized somehow.
        """
        raise NotImplementedError('The roll method must be implemented')


class Dice(object):
    """
    A group of dice, all with the same number of sides. Such a group is just
    composed of a quantity of dice, and their number of sides.

    Both the quantity and the number of sides are expected to be positive, as
    any other value would make no sense.

    No other limitation is expected. In the real world the number of sides
    which a die may physically have are limited by the rules of geometry,
    but there is no reason to take care of that.
    """

    def __init__(self, quantity, sides):
        super(Dice, self).__init__()
        self._quantity = quantity
        self._sides = sides

    def __str__(self):
        return '%sd%s' % (self._quantity, self._sides)

    def __repr__(self):
        return '<class %s>(quantity=%r, sides=%r)' % \
               (self.__class__.__name__, self._quantity, self._sides)

    @property
    def quantity(self):
        """
        The number of dice which compose this group.

        This is expected to be a positive value or zero.

        :return: the number of dice
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity):
        self._quantity = quantity

    @property
    def sides(self):
        """
        The number of sides each die has.

        All the dice in the group have the same number of sides.

        This is expected to be a positive value or zero.

        :return: the number of sides
        """
        return self._sides

    @sides.setter
    def sides(self, sides):
        self._sides = sides


class RollableDice(Dice, Rollable):
    """
    A rollable dice group.

    The result of calling the roll method will be an integer, which will be
    between 1 and the number of sides. Actually one number will be generated
    like that as many times as the value of the quantity field, and all those
    values will be added, and then returned.
    """

    def __init__(self, quantity, sides):
        super(RollableDice, self).__init__(quantity, sides)

    def roll(self):
        result = 0

        if self.quantity == 0 or self.sides == 0:
            result = 0
        elif self.quantity is None or self.sides is None:
            result = None
        elif self.quantity > 0 and self.sides > 0:
            for x in range(self.quantity):
                result += randint(1, self.sides)
        else:
            result = None

        return result
